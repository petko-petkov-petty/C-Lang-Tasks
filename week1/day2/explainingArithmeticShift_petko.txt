ИЗЛОЖЕНИЕ НА ПРОБЛЕМА
{
    ОТМЕСТВАНЕ НАДЯСНО ЗА UNSIGNED INT
    {
        За unsigned int x, 
        където х >= 0 && x <= (2^31 - 1), 
        т.е. x =        0 b30 b29 ... b2 b1 b0, за bi = {0, 1},
        при отместване с един бит надясно,
        т.е. x >> 1 ==  0  0  b30 ... b3 b2 b1,
        получаваме х/2,
        като за четни х резултатът е цяло число,
        а за нечетни х резултатът е закръглен към най-близкото цяло число в посока към 0-та.
            Пример: За х = 10 резултатът на х >> 1 е 5 /или 00...001010 >> 1 == 00...000101/.
                    За х = 5  резултатът на x >> 1 е 2 /или 00...000101 >> 1 == 00...000010/.   

        За unsigned int x, 
        където х >= 2^31 && x <= (2^32 - 1),
        т.е. x =        1 b30 b29 ... b2 b1 b0, за bi = {0, 1},
        при отместване с един бит надясно,
        т.е. x >> 1 ==  0  1  b30 ... b3 b2 b1,
        получаваме х/2,
        като за четни х резултатът е цяло число,
        а за нечетни х резултатът е закръглен към най-близкото цяло число в посока към 0-та.
            Пример: За х = 4294967286 резултатът на х >> 1 е 2147483643 /или 11...110110 >> 1 == 01...111011/,
                    за х = 4294967291 резултатът на x >> 1 е 2147483645 /или 11...111011 >> 1 == 01...111101/.

        Т.е. отместването с бит надясно,
        водещо до деление на 2, 
        има еднакво поведението за всички стойности на unsigned int.
    }

    ОТМЕСТВАНЕ НАДЯСНО ЗА SIGNED INT
    {
        За signed int х, 
        където x >= 0 && x <= (2^31 - 1),
        т.е. x =        0 b30 b29 ... b2 b1 b0, за bi = {0, 1},
        при отместване с един бит надясно,
        т.е. x >> 1 ==  0  0  b30 ... b3 b2 b1,
        получаваме х/2, 
        като за четни х резултатът е цяло число, 
        а за нечетни х резултатът е закръглен към най-близкото цяло число в посока към 0-та.
            Пример: За х = 10 резултатът на х >> 1 е 5 /или 00...001010 >> 1 == 00...000101/.
                    За х = 5  резултатът на x >> 1 е 2 /или 00...000101 >> 1 == 00...000010/.

        За signed int x,
        където х < 0 && x >= -2^31, 
        т.е. x =        1 b30 b29 ... b2 b1 b0, за bi = {0, 1},
        при отместване с един бит надясно,
        т.е. x >> 1 ==  1  1  b30 ... b3 b2 b1,
        получаваме х/2, 
        като за четни х резултатът е цяло число,
        а за нечетни х резултатът е закръглен към предходното цяло число в посока към минус безкрайност.
            Пример: За х = -10 резултатът на х >> 1 е -5 /или 11...110110 >> 1 == 11...111011/.
                    За х = -5  резултатът на x >> 1 е -3 /или 11...111011 >> 1 == 11...111101/.

        Т.е. отместването с бит надясно, 
        водещо до деление на 2, 
        има различно поведение за стойностите на signed int, 
        в зависимост дали са по-малки, или по-големи от 0.
    }
}

ОБЯСНЕНИЕ ЗА ПРИЧИНИТЕ
{
    Причината за наблюдаваното разминаване в десетичния запис на числата при отместване с бит надясно
    на отрицателните стойности за signed int спрямо положителните стойности на signed int, 
    както и спрямо стойностите на unsigned int,
    се дължи на това, че отрицателсните стойности за signed int имат най-старши бит 1, 
    който при прилагане на отместване надясно пропагира, 
    докато няй-младшият бит изпада.
    както е видно от изложението по-горе.

    Към правилото за пропагиране на най-старшия бит в signed int, 
    прилагайки и 2's complement правилото за преобразуване на отрицателна в положителна стойност, 
    където -x = ~x + 1, по индукция разбираме, че:
    за х = -1 /или 11...111111/ х >> 1 == -1 /или 11...111111/ 
    за х = -2 /или 11...111110/ х >> 1 == -1 /или 11...111111/
    за х = -3 /или 11...111101/ х >> 1 == -2 /или 11...111110/
    за х = -4 /или 11...111100/ х >> 1 == -2 /или 11...111110/
    за х = -5 /или 11...111011/ х >> 1 == -3 /или 11...111101/
    за х = -6 /или 11...111010/ х >> 1 == -3 /или 11...111101/

    за х = 0 /или 00...000000/ х >> 1 == 0 /или 00...000000/
    за х = 1 /или 00...000001/ х >> 1 == 0 /или 00...000000/
    за х = 2 /или 00...000010/ х >> 1 == 1 /или 00...000001/
    за х = 3 /или 00...000011/ х >> 1 == 1 /или 00...000001/
    за х = 4 /или 00...000100/ х >> 1 == 2 /или 00...000010/
    за х = 5 /или 00...000101/ х >> 1 == 2 /или 00...000010/

    За положителните стойности възможно най-малката стойност при делене на 2 е 0 (тъй като пропагира бит 0):
    0 / 2 = 0
    1 / 2 = 0
    ...
    докато за отрицателните стойности възможно най-малката стойност при делене на 2 е -1 (тъй като пропагира бит 1):
    -1 / 2 = -1
    -2 / 2 = -1
    ...
    Т.е. се получава разминаване, защото -1 / 2 ни дава -1 вместо 0,
    от което по индукция идва грешката при деление на нечетни отрицателни числа.
}